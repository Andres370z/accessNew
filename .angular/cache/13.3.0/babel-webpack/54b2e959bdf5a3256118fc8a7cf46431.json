{"ast":null,"code":"import _assertThisInitialized from \"/Users/apple/Documents/AccessControlSoft/accesscontrolsoft/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"/Users/apple/Documents/AccessControlSoft/accesscontrolsoft/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/apple/Documents/AccessControlSoft/accesscontrolsoft/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _toConsumableArray from \"/Users/apple/Documents/AccessControlSoft/accesscontrolsoft/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/Users/apple/Documents/AccessControlSoft/accesscontrolsoft/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/apple/Documents/AccessControlSoft/accesscontrolsoft/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/AccessControlSoft/accesscontrolsoft/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/apple/Documents/AccessControlSoft/accesscontrolsoft/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/apple/Documents/AccessControlSoft/accesscontrolsoft/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { DateComponent, getStickyHeaderDates, ViewContainer, SimpleScrollGrid, getStickyFooterScrollbar, renderScrollShim, createFormatter, BaseComponent, StandardEvent, buildSegTimeText, EventContainer, getSegAnchorAttrs, memoize, MoreLinkContainer, getSegMeta, getUniqueDomId, setRef, DayCellContainer, WeekNumberContainer, buildNavLinkAttrs, hasCustomDayCellContent, intersectRanges, addDays, SegHierarchy, buildEntryKey, intersectSpans, RefMap, sortEventSegs, isPropsEqual, buildEventRangeKey, BgEvent, renderFill, PositionCache, NowTimer, Slicer, DayHeader, DaySeriesModel, DayTableModel } from '@fullcalendar/core/internal.js';\nimport { createRef, createElement, Fragment } from '@fullcalendar/core/preact.js';\n/* An abstract class for the daygrid views, as well as month view. Renders one or more rows of day cells.\n----------------------------------------------------------------------------------------------------------------------*/\n// It is a manager for a Table subcomponent, which does most of the heavy lifting.\n// It is responsible for managing width/height.\n\nvar TableView = /*#__PURE__*/function (_DateComponent) {\n  _inherits(TableView, _DateComponent);\n\n  var _super = _createSuper(TableView);\n\n  function TableView() {\n    var _this;\n\n    _classCallCheck(this, TableView);\n\n    _this = _super.apply(this, arguments);\n    _this.headerElRef = createRef();\n    return _this;\n  }\n\n  _createClass(TableView, [{\n    key: \"renderSimpleLayout\",\n    value: function renderSimpleLayout(headerRowContent, bodyContent) {\n      var props = this.props,\n          context = this.context;\n      var sections = [];\n      var stickyHeaderDates = getStickyHeaderDates(context.options);\n\n      if (headerRowContent) {\n        sections.push({\n          type: 'header',\n          key: 'header',\n          isSticky: stickyHeaderDates,\n          chunk: {\n            elRef: this.headerElRef,\n            tableClassName: 'fc-col-header',\n            rowContent: headerRowContent\n          }\n        });\n      }\n\n      sections.push({\n        type: 'body',\n        key: 'body',\n        liquid: true,\n        chunk: {\n          content: bodyContent\n        }\n      });\n      return createElement(ViewContainer, {\n        elClasses: ['fc-daygrid'],\n        viewSpec: context.viewSpec\n      }, createElement(SimpleScrollGrid, {\n        liquid: !props.isHeightAuto && !props.forPrint,\n        collapsibleWidth: props.forPrint,\n        cols: []\n        /* TODO: make optional? */\n        ,\n        sections: sections\n      }));\n    }\n  }, {\n    key: \"renderHScrollLayout\",\n    value: function renderHScrollLayout(headerRowContent, bodyContent, colCnt, dayMinWidth) {\n      var ScrollGrid = this.context.pluginHooks.scrollGridImpl;\n\n      if (!ScrollGrid) {\n        throw new Error('No ScrollGrid implementation');\n      }\n\n      var props = this.props,\n          context = this.context;\n      var stickyHeaderDates = !props.forPrint && getStickyHeaderDates(context.options);\n      var stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(context.options);\n      var sections = [];\n\n      if (headerRowContent) {\n        sections.push({\n          type: 'header',\n          key: 'header',\n          isSticky: stickyHeaderDates,\n          chunks: [{\n            key: 'main',\n            elRef: this.headerElRef,\n            tableClassName: 'fc-col-header',\n            rowContent: headerRowContent\n          }]\n        });\n      }\n\n      sections.push({\n        type: 'body',\n        key: 'body',\n        liquid: true,\n        chunks: [{\n          key: 'main',\n          content: bodyContent\n        }]\n      });\n\n      if (stickyFooterScrollbar) {\n        sections.push({\n          type: 'footer',\n          key: 'footer',\n          isSticky: true,\n          chunks: [{\n            key: 'main',\n            content: renderScrollShim\n          }]\n        });\n      }\n\n      return createElement(ViewContainer, {\n        elClasses: ['fc-daygrid'],\n        viewSpec: context.viewSpec\n      }, createElement(ScrollGrid, {\n        liquid: !props.isHeightAuto && !props.forPrint,\n        collapsibleWidth: props.forPrint,\n        colGroups: [{\n          cols: [{\n            span: colCnt,\n            minWidth: dayMinWidth\n          }]\n        }],\n        sections: sections\n      }));\n    }\n  }]);\n\n  return TableView;\n}(DateComponent);\n\nfunction splitSegsByRow(segs, rowCnt) {\n  var byRow = [];\n\n  for (var i = 0; i < rowCnt; i += 1) {\n    byRow[i] = [];\n  }\n\n  var _iterator = _createForOfIteratorHelper(segs),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var seg = _step.value;\n      byRow[seg.row].push(seg);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return byRow;\n}\n\nfunction splitSegsByFirstCol(segs, colCnt) {\n  var byCol = [];\n\n  for (var i = 0; i < colCnt; i += 1) {\n    byCol[i] = [];\n  }\n\n  var _iterator2 = _createForOfIteratorHelper(segs),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var seg = _step2.value;\n      byCol[seg.firstCol].push(seg);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return byCol;\n}\n\nfunction splitInteractionByRow(ui, rowCnt) {\n  var byRow = [];\n\n  if (!ui) {\n    for (var i = 0; i < rowCnt; i += 1) {\n      byRow[i] = null;\n    }\n  } else {\n    for (var _i = 0; _i < rowCnt; _i += 1) {\n      byRow[_i] = {\n        affectedInstances: ui.affectedInstances,\n        isEvent: ui.isEvent,\n        segs: []\n      };\n    }\n\n    var _iterator3 = _createForOfIteratorHelper(ui.segs),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var seg = _step3.value;\n        byRow[seg.row].segs.push(seg);\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  }\n\n  return byRow;\n}\n\nvar DEFAULT_TABLE_EVENT_TIME_FORMAT = createFormatter({\n  hour: 'numeric',\n  minute: '2-digit',\n  omitZeroMinute: true,\n  meridiem: 'narrow'\n});\n\nfunction hasListItemDisplay(seg) {\n  var display = seg.eventRange.ui.display;\n  return display === 'list-item' || display === 'auto' && !seg.eventRange.def.allDay && seg.firstCol === seg.lastCol && // can't be multi-day\n  seg.isStart && // \"\n  seg.isEnd // \"\n  ;\n}\n\nvar TableBlockEvent = /*#__PURE__*/function (_BaseComponent) {\n  _inherits(TableBlockEvent, _BaseComponent);\n\n  var _super2 = _createSuper(TableBlockEvent);\n\n  function TableBlockEvent() {\n    _classCallCheck(this, TableBlockEvent);\n\n    return _super2.apply(this, arguments);\n  }\n\n  _createClass(TableBlockEvent, [{\n    key: \"render\",\n    value: function render() {\n      var props = this.props;\n      return createElement(StandardEvent, Object.assign({}, props, {\n        elClasses: ['fc-daygrid-event', 'fc-daygrid-block-event', 'fc-h-event'],\n        defaultTimeFormat: DEFAULT_TABLE_EVENT_TIME_FORMAT,\n        defaultDisplayEventEnd: props.defaultDisplayEventEnd,\n        disableResizing: !props.seg.eventRange.def.allDay\n      }));\n    }\n  }]);\n\n  return TableBlockEvent;\n}(BaseComponent);\n\nvar TableListItemEvent = /*#__PURE__*/function (_BaseComponent2) {\n  _inherits(TableListItemEvent, _BaseComponent2);\n\n  var _super3 = _createSuper(TableListItemEvent);\n\n  function TableListItemEvent() {\n    _classCallCheck(this, TableListItemEvent);\n\n    return _super3.apply(this, arguments);\n  }\n\n  _createClass(TableListItemEvent, [{\n    key: \"render\",\n    value: function render() {\n      var props = this.props,\n          context = this.context;\n      var options = context.options;\n      var seg = props.seg;\n      var timeFormat = options.eventTimeFormat || DEFAULT_TABLE_EVENT_TIME_FORMAT;\n      var timeText = buildSegTimeText(seg, timeFormat, context, true, props.defaultDisplayEventEnd);\n      return createElement(EventContainer, Object.assign({}, props, {\n        elTag: \"a\",\n        elClasses: ['fc-daygrid-event', 'fc-daygrid-dot-event'],\n        elAttrs: getSegAnchorAttrs(props.seg, context),\n        defaultGenerator: renderInnerContent,\n        timeText: timeText,\n        isResizing: false,\n        isDateSelecting: false\n      }));\n    }\n  }]);\n\n  return TableListItemEvent;\n}(BaseComponent);\n\nfunction renderInnerContent(renderProps) {\n  return createElement(Fragment, null, createElement(\"div\", {\n    className: \"fc-daygrid-event-dot\",\n    style: {\n      borderColor: renderProps.borderColor || renderProps.backgroundColor\n    }\n  }), renderProps.timeText && createElement(\"div\", {\n    className: \"fc-event-time\"\n  }, renderProps.timeText), createElement(\"div\", {\n    className: \"fc-event-title\"\n  }, renderProps.event.title || createElement(Fragment, null, \"\\xA0\")));\n}\n\nvar TableCellMoreLink = /*#__PURE__*/function (_BaseComponent3) {\n  _inherits(TableCellMoreLink, _BaseComponent3);\n\n  var _super4 = _createSuper(TableCellMoreLink);\n\n  function TableCellMoreLink() {\n    var _this2;\n\n    _classCallCheck(this, TableCellMoreLink);\n\n    _this2 = _super4.apply(this, arguments);\n    _this2.compileSegs = memoize(compileSegs);\n    return _this2;\n  }\n\n  _createClass(TableCellMoreLink, [{\n    key: \"render\",\n    value: function render() {\n      var props = this.props;\n\n      var _this$compileSegs = this.compileSegs(props.singlePlacements),\n          allSegs = _this$compileSegs.allSegs,\n          invisibleSegs = _this$compileSegs.invisibleSegs;\n\n      return createElement(MoreLinkContainer, {\n        elClasses: ['fc-daygrid-more-link'],\n        dateProfile: props.dateProfile,\n        todayRange: props.todayRange,\n        allDayDate: props.allDayDate,\n        moreCnt: props.moreCnt,\n        allSegs: allSegs,\n        hiddenSegs: invisibleSegs,\n        alignmentElRef: props.alignmentElRef,\n        alignGridTop: props.alignGridTop,\n        extraDateSpan: props.extraDateSpan,\n        popoverContent: function popoverContent() {\n          var isForcedInvisible = (props.eventDrag ? props.eventDrag.affectedInstances : null) || (props.eventResize ? props.eventResize.affectedInstances : null) || {};\n          return createElement(Fragment, null, allSegs.map(function (seg) {\n            var instanceId = seg.eventRange.instance.instanceId;\n            return createElement(\"div\", {\n              className: \"fc-daygrid-event-harness\",\n              key: instanceId,\n              style: {\n                visibility: isForcedInvisible[instanceId] ? 'hidden' : ''\n              }\n            }, hasListItemDisplay(seg) ? createElement(TableListItemEvent, Object.assign({\n              seg: seg,\n              isDragging: false,\n              isSelected: instanceId === props.eventSelection,\n              defaultDisplayEventEnd: false\n            }, getSegMeta(seg, props.todayRange))) : createElement(TableBlockEvent, Object.assign({\n              seg: seg,\n              isDragging: false,\n              isResizing: false,\n              isDateSelecting: false,\n              isSelected: instanceId === props.eventSelection,\n              defaultDisplayEventEnd: false\n            }, getSegMeta(seg, props.todayRange))));\n          }));\n        }\n      });\n    }\n  }]);\n\n  return TableCellMoreLink;\n}(BaseComponent);\n\nfunction compileSegs(singlePlacements) {\n  var allSegs = [];\n  var invisibleSegs = [];\n\n  var _iterator4 = _createForOfIteratorHelper(singlePlacements),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var placement = _step4.value;\n      allSegs.push(placement.seg);\n\n      if (!placement.isVisible) {\n        invisibleSegs.push(placement.seg);\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  return {\n    allSegs: allSegs,\n    invisibleSegs: invisibleSegs\n  };\n}\n\nvar DEFAULT_WEEK_NUM_FORMAT = createFormatter({\n  week: 'narrow'\n});\n\nvar TableCell = /*#__PURE__*/function (_DateComponent2) {\n  _inherits(TableCell, _DateComponent2);\n\n  var _super5 = _createSuper(TableCell);\n\n  function TableCell() {\n    var _this3;\n\n    _classCallCheck(this, TableCell);\n\n    _this3 = _super5.apply(this, arguments);\n    _this3.rootElRef = createRef();\n    _this3.state = {\n      dayNumberId: getUniqueDomId()\n    };\n\n    _this3.handleRootEl = function (el) {\n      setRef(_this3.rootElRef, el);\n      setRef(_this3.props.elRef, el);\n    };\n\n    return _this3;\n  }\n\n  _createClass(TableCell, [{\n    key: \"render\",\n    value: function render() {\n      var context = this.context,\n          props = this.props,\n          state = this.state,\n          rootElRef = this.rootElRef;\n      var options = context.options;\n      var date = props.date,\n          dateProfile = props.dateProfile;\n      return createElement(DayCellContainer, {\n        elTag: \"td\",\n        elRef: this.handleRootEl,\n        elClasses: ['fc-daygrid-day'].concat(_toConsumableArray(props.extraClassNames || [])),\n        elAttrs: Object.assign(Object.assign(Object.assign({}, props.extraDataAttrs), props.showDayNumber ? {\n          'aria-labelledby': state.dayNumberId\n        } : {}), {\n          role: 'gridcell'\n        }),\n        defaultGenerator: renderTopInner,\n        date: date,\n        dateProfile: dateProfile,\n        todayRange: props.todayRange,\n        showDayNumber: props.showDayNumber,\n        extraRenderProps: props.extraRenderProps\n      }, function (InnerContent, renderProps) {\n        return createElement(\"div\", {\n          className: \"fc-daygrid-day-frame fc-scrollgrid-sync-inner\",\n          ref: props.innerElRef\n        }, props.showWeekNumber && createElement(WeekNumberContainer, {\n          elTag: \"a\",\n          elClasses: ['fc-daygrid-week-number'],\n          elAttrs: buildNavLinkAttrs(context, date, 'week'),\n          date: date,\n          defaultFormat: DEFAULT_WEEK_NUM_FORMAT\n        }), Boolean(!renderProps.isDisabled && (props.showDayNumber || hasCustomDayCellContent(options) || props.forceDayTop)) && createElement(\"div\", {\n          className: \"fc-daygrid-day-top\"\n        }, createElement(InnerContent, {\n          elTag: \"a\",\n          elClasses: ['fc-daygrid-day-number'],\n          elAttrs: Object.assign(Object.assign({}, buildNavLinkAttrs(context, date)), {\n            id: state.dayNumberId\n          })\n        })), createElement(\"div\", {\n          className: \"fc-daygrid-day-events\",\n          ref: props.fgContentElRef\n        }, props.fgContent, createElement(\"div\", {\n          className: \"fc-daygrid-day-bottom\",\n          style: {\n            marginTop: props.moreMarginTop\n          }\n        }, createElement(TableCellMoreLink, {\n          allDayDate: date,\n          singlePlacements: props.singlePlacements,\n          moreCnt: props.moreCnt,\n          alignmentElRef: rootElRef,\n          alignGridTop: !props.showDayNumber,\n          extraDateSpan: props.extraDateSpan,\n          dateProfile: props.dateProfile,\n          eventSelection: props.eventSelection,\n          eventDrag: props.eventDrag,\n          eventResize: props.eventResize,\n          todayRange: props.todayRange\n        }))), createElement(\"div\", {\n          className: \"fc-daygrid-day-bg\"\n        }, props.bgContent));\n      });\n    }\n  }]);\n\n  return TableCell;\n}(DateComponent);\n\nfunction renderTopInner(props) {\n  return props.dayNumberText || createElement(Fragment, null, \"\\xA0\");\n}\n\nfunction computeFgSegPlacement(segs, // assumed already sorted\ndayMaxEvents, dayMaxEventRows, strictOrder, eventInstanceHeights, maxContentHeight, cells) {\n  var hierarchy = new DayGridSegHierarchy();\n  hierarchy.allowReslicing = true;\n  hierarchy.strictOrder = strictOrder;\n\n  if (dayMaxEvents === true || dayMaxEventRows === true) {\n    hierarchy.maxCoord = maxContentHeight;\n    hierarchy.hiddenConsumes = true;\n  } else if (typeof dayMaxEvents === 'number') {\n    hierarchy.maxStackCnt = dayMaxEvents;\n  } else if (typeof dayMaxEventRows === 'number') {\n    hierarchy.maxStackCnt = dayMaxEventRows;\n    hierarchy.hiddenConsumes = true;\n  } // create segInputs only for segs with known heights\n\n\n  var segInputs = [];\n  var unknownHeightSegs = [];\n\n  for (var i = 0; i < segs.length; i += 1) {\n    var seg = segs[i];\n    var instanceId = seg.eventRange.instance.instanceId;\n    var eventHeight = eventInstanceHeights[instanceId];\n\n    if (eventHeight != null) {\n      segInputs.push({\n        index: i,\n        thickness: eventHeight,\n        span: {\n          start: seg.firstCol,\n          end: seg.lastCol + 1\n        }\n      });\n    } else {\n      unknownHeightSegs.push(seg);\n    }\n  }\n\n  var hiddenEntries = hierarchy.addSegs(segInputs);\n  var segRects = hierarchy.toRects();\n\n  var _placeRects = placeRects(segRects, segs, cells),\n      singleColPlacements = _placeRects.singleColPlacements,\n      multiColPlacements = _placeRects.multiColPlacements,\n      leftoverMargins = _placeRects.leftoverMargins;\n\n  var moreCnts = [];\n  var moreMarginTops = []; // add segs with unknown heights\n\n  for (var _i2 = 0, _unknownHeightSegs = unknownHeightSegs; _i2 < _unknownHeightSegs.length; _i2++) {\n    var _seg = _unknownHeightSegs[_i2];\n\n    multiColPlacements[_seg.firstCol].push({\n      seg: _seg,\n      isVisible: false,\n      isAbsolute: true,\n      absoluteTop: 0,\n      marginTop: 0\n    });\n\n    for (var col = _seg.firstCol; col <= _seg.lastCol; col += 1) {\n      singleColPlacements[col].push({\n        seg: resliceSeg(_seg, col, col + 1, cells),\n        isVisible: false,\n        isAbsolute: false,\n        absoluteTop: 0,\n        marginTop: 0\n      });\n    }\n  } // add the hidden entries\n\n\n  for (var _col = 0; _col < cells.length; _col += 1) {\n    moreCnts.push(0);\n  }\n\n  var _iterator5 = _createForOfIteratorHelper(hiddenEntries),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var hiddenEntry = _step5.value;\n      var _seg2 = segs[hiddenEntry.index];\n      var hiddenSpan = hiddenEntry.span;\n      multiColPlacements[hiddenSpan.start].push({\n        seg: resliceSeg(_seg2, hiddenSpan.start, hiddenSpan.end, cells),\n        isVisible: false,\n        isAbsolute: true,\n        absoluteTop: 0,\n        marginTop: 0\n      });\n\n      for (var _col3 = hiddenSpan.start; _col3 < hiddenSpan.end; _col3 += 1) {\n        moreCnts[_col3] += 1;\n\n        singleColPlacements[_col3].push({\n          seg: resliceSeg(_seg2, _col3, _col3 + 1, cells),\n          isVisible: false,\n          isAbsolute: false,\n          absoluteTop: 0,\n          marginTop: 0\n        });\n      }\n    } // deal with leftover margins\n\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n\n  for (var _col2 = 0; _col2 < cells.length; _col2 += 1) {\n    moreMarginTops.push(leftoverMargins[_col2]);\n  }\n\n  return {\n    singleColPlacements: singleColPlacements,\n    multiColPlacements: multiColPlacements,\n    moreCnts: moreCnts,\n    moreMarginTops: moreMarginTops\n  };\n} // rects ordered by top coord, then left\n\n\nfunction placeRects(allRects, segs, cells) {\n  var rectsByEachCol = groupRectsByEachCol(allRects, cells.length);\n  var singleColPlacements = [];\n  var multiColPlacements = [];\n  var leftoverMargins = [];\n\n  for (var col = 0; col < cells.length; col += 1) {\n    var rects = rectsByEachCol[col]; // compute all static segs in singlePlacements\n\n    var singlePlacements = [];\n    var currentHeight = 0;\n    var currentMarginTop = 0;\n\n    var _iterator6 = _createForOfIteratorHelper(rects),\n        _step6;\n\n    try {\n      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n        var rect = _step6.value;\n        var seg = segs[rect.index];\n        singlePlacements.push({\n          seg: resliceSeg(seg, col, col + 1, cells),\n          isVisible: true,\n          isAbsolute: false,\n          absoluteTop: rect.levelCoord,\n          marginTop: rect.levelCoord - currentHeight\n        });\n        currentHeight = rect.levelCoord + rect.thickness;\n      } // compute mixed static/absolute segs in multiPlacements\n\n    } catch (err) {\n      _iterator6.e(err);\n    } finally {\n      _iterator6.f();\n    }\n\n    var multiPlacements = [];\n    currentHeight = 0;\n    currentMarginTop = 0;\n\n    var _iterator7 = _createForOfIteratorHelper(rects),\n        _step7;\n\n    try {\n      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n        var _rect = _step7.value;\n        var _seg3 = segs[_rect.index];\n        var isAbsolute = _rect.span.end - _rect.span.start > 1; // multi-column?\n\n        var isFirstCol = _rect.span.start === col;\n        currentMarginTop += _rect.levelCoord - currentHeight; // amount of space since bottom of previous seg\n\n        currentHeight = _rect.levelCoord + _rect.thickness; // height will now be bottom of current seg\n\n        if (isAbsolute) {\n          currentMarginTop += _rect.thickness;\n\n          if (isFirstCol) {\n            multiPlacements.push({\n              seg: resliceSeg(_seg3, _rect.span.start, _rect.span.end, cells),\n              isVisible: true,\n              isAbsolute: true,\n              absoluteTop: _rect.levelCoord,\n              marginTop: 0\n            });\n          }\n        } else if (isFirstCol) {\n          multiPlacements.push({\n            seg: resliceSeg(_seg3, _rect.span.start, _rect.span.end, cells),\n            isVisible: true,\n            isAbsolute: false,\n            absoluteTop: _rect.levelCoord,\n            marginTop: currentMarginTop // claim the margin\n\n          });\n          currentMarginTop = 0;\n        }\n      }\n    } catch (err) {\n      _iterator7.e(err);\n    } finally {\n      _iterator7.f();\n    }\n\n    singleColPlacements.push(singlePlacements);\n    multiColPlacements.push(multiPlacements);\n    leftoverMargins.push(currentMarginTop);\n  }\n\n  return {\n    singleColPlacements: singleColPlacements,\n    multiColPlacements: multiColPlacements,\n    leftoverMargins: leftoverMargins\n  };\n}\n\nfunction groupRectsByEachCol(rects, colCnt) {\n  var rectsByEachCol = [];\n\n  for (var col = 0; col < colCnt; col += 1) {\n    rectsByEachCol.push([]);\n  }\n\n  var _iterator8 = _createForOfIteratorHelper(rects),\n      _step8;\n\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var rect = _step8.value;\n\n      for (var _col4 = rect.span.start; _col4 < rect.span.end; _col4 += 1) {\n        rectsByEachCol[_col4].push(rect);\n      }\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n\n  return rectsByEachCol;\n}\n\nfunction resliceSeg(seg, spanStart, spanEnd, cells) {\n  if (seg.firstCol === spanStart && seg.lastCol === spanEnd - 1) {\n    return seg;\n  }\n\n  var eventRange = seg.eventRange;\n  var origRange = eventRange.range;\n  var slicedRange = intersectRanges(origRange, {\n    start: cells[spanStart].date,\n    end: addDays(cells[spanEnd - 1].date, 1)\n  });\n  return Object.assign(Object.assign({}, seg), {\n    firstCol: spanStart,\n    lastCol: spanEnd - 1,\n    eventRange: {\n      def: eventRange.def,\n      ui: Object.assign(Object.assign({}, eventRange.ui), {\n        durationEditable: false\n      }),\n      instance: eventRange.instance,\n      range: slicedRange\n    },\n    isStart: seg.isStart && slicedRange.start.valueOf() === origRange.start.valueOf(),\n    isEnd: seg.isEnd && slicedRange.end.valueOf() === origRange.end.valueOf()\n  });\n}\n\nvar DayGridSegHierarchy = /*#__PURE__*/function (_SegHierarchy) {\n  _inherits(DayGridSegHierarchy, _SegHierarchy);\n\n  var _super6 = _createSuper(DayGridSegHierarchy);\n\n  function DayGridSegHierarchy() {\n    var _this4;\n\n    _classCallCheck(this, DayGridSegHierarchy);\n\n    _this4 = _super6.apply(this, arguments); // config\n\n    _this4.hiddenConsumes = false; // allows us to keep hidden entries in the hierarchy so they take up space\n\n    _this4.forceHidden = {};\n    return _this4;\n  }\n\n  _createClass(DayGridSegHierarchy, [{\n    key: \"addSegs\",\n    value: function addSegs(segInputs) {\n      var _this5 = this;\n\n      var hiddenSegs = _get(_getPrototypeOf(DayGridSegHierarchy.prototype), \"addSegs\", this).call(this, segInputs);\n\n      var entriesByLevel = this.entriesByLevel;\n\n      var excludeHidden = function excludeHidden(entry) {\n        return !_this5.forceHidden[buildEntryKey(entry)];\n      }; // remove the forced-hidden segs\n\n\n      for (var level = 0; level < entriesByLevel.length; level += 1) {\n        entriesByLevel[level] = entriesByLevel[level].filter(excludeHidden);\n      }\n\n      return hiddenSegs;\n    }\n  }, {\n    key: \"handleInvalidInsertion\",\n    value: function handleInvalidInsertion(insertion, entry, hiddenEntries) {\n      var entriesByLevel = this.entriesByLevel,\n          forceHidden = this.forceHidden;\n      var touchingEntry = insertion.touchingEntry,\n          touchingLevel = insertion.touchingLevel,\n          touchingLateral = insertion.touchingLateral;\n\n      if (this.hiddenConsumes && touchingEntry) {\n        var touchingEntryId = buildEntryKey(touchingEntry); // if not already hidden\n\n        if (!forceHidden[touchingEntryId]) {\n          if (this.allowReslicing) {\n            var placeholderEntry = Object.assign(Object.assign({}, touchingEntry), {\n              span: intersectSpans(touchingEntry.span, entry.span)\n            });\n            var placeholderEntryId = buildEntryKey(placeholderEntry);\n            forceHidden[placeholderEntryId] = true;\n            entriesByLevel[touchingLevel][touchingLateral] = placeholderEntry; // replace touchingEntry with our placeholder\n\n            this.splitEntry(touchingEntry, entry, hiddenEntries); // split up the touchingEntry, reinsert it\n          } else {\n            forceHidden[touchingEntryId] = true;\n            hiddenEntries.push(touchingEntry);\n          }\n        }\n      }\n\n      return _get(_getPrototypeOf(DayGridSegHierarchy.prototype), \"handleInvalidInsertion\", this).call(this, insertion, entry, hiddenEntries);\n    }\n  }]);\n\n  return DayGridSegHierarchy;\n}(SegHierarchy);\n\nvar TableRow = /*#__PURE__*/function (_DateComponent3) {\n  _inherits(TableRow, _DateComponent3);\n\n  var _super7 = _createSuper(TableRow);\n\n  function TableRow() {\n    var _this6;\n\n    _classCallCheck(this, TableRow);\n\n    _this6 = _super7.apply(this, arguments);\n    _this6.cellElRefs = new RefMap(); // the <td>\n\n    _this6.frameElRefs = new RefMap(); // the fc-daygrid-day-frame\n\n    _this6.fgElRefs = new RefMap(); // the fc-daygrid-day-events\n\n    _this6.segHarnessRefs = new RefMap(); // indexed by \"instanceId:firstCol\"\n\n    _this6.rootElRef = createRef();\n    _this6.state = {\n      framePositions: null,\n      maxContentHeight: null,\n      eventInstanceHeights: {}\n    };\n\n    _this6.handleResize = function (isForced) {\n      if (isForced) {\n        _this6.updateSizing(true); // isExternal=true\n\n      }\n    };\n\n    return _this6;\n  }\n\n  _createClass(TableRow, [{\n    key: \"render\",\n    value: function render() {\n      var _this7 = this;\n\n      var props = this.props,\n          state = this.state,\n          context = this.context;\n      var options = context.options;\n      var colCnt = props.cells.length;\n      var businessHoursByCol = splitSegsByFirstCol(props.businessHourSegs, colCnt);\n      var bgEventSegsByCol = splitSegsByFirstCol(props.bgEventSegs, colCnt);\n      var highlightSegsByCol = splitSegsByFirstCol(this.getHighlightSegs(), colCnt);\n      var mirrorSegsByCol = splitSegsByFirstCol(this.getMirrorSegs(), colCnt);\n\n      var _computeFgSegPlacemen = computeFgSegPlacement(sortEventSegs(props.fgEventSegs, options.eventOrder), props.dayMaxEvents, props.dayMaxEventRows, options.eventOrderStrict, state.eventInstanceHeights, state.maxContentHeight, props.cells),\n          singleColPlacements = _computeFgSegPlacemen.singleColPlacements,\n          multiColPlacements = _computeFgSegPlacemen.multiColPlacements,\n          moreCnts = _computeFgSegPlacemen.moreCnts,\n          moreMarginTops = _computeFgSegPlacemen.moreMarginTops;\n\n      var isForcedInvisible = // TODO: messy way to compute this\n      props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {};\n      return createElement(\"tr\", {\n        ref: this.rootElRef,\n        role: \"row\"\n      }, props.renderIntro && props.renderIntro(), props.cells.map(function (cell, col) {\n        var normalFgNodes = _this7.renderFgSegs(col, props.forPrint ? singleColPlacements[col] : multiColPlacements[col], props.todayRange, isForcedInvisible);\n\n        var mirrorFgNodes = _this7.renderFgSegs(col, buildMirrorPlacements(mirrorSegsByCol[col], multiColPlacements), props.todayRange, {}, Boolean(props.eventDrag), Boolean(props.eventResize), false);\n\n        return createElement(TableCell, {\n          key: cell.key,\n          elRef: _this7.cellElRefs.createRef(cell.key),\n          innerElRef: _this7.frameElRefs.createRef(cell.key)\n          /* FF <td> problem, but okay to use for left/right. TODO: rename prop */\n          ,\n          dateProfile: props.dateProfile,\n          date: cell.date,\n          showDayNumber: props.showDayNumbers,\n          showWeekNumber: props.showWeekNumbers && col === 0,\n          forceDayTop: props.showWeekNumbers\n          /* even displaying weeknum for row, not necessarily day */\n          ,\n          todayRange: props.todayRange,\n          eventSelection: props.eventSelection,\n          eventDrag: props.eventDrag,\n          eventResize: props.eventResize,\n          extraRenderProps: cell.extraRenderProps,\n          extraDataAttrs: cell.extraDataAttrs,\n          extraClassNames: cell.extraClassNames,\n          extraDateSpan: cell.extraDateSpan,\n          moreCnt: moreCnts[col],\n          moreMarginTop: moreMarginTops[col],\n          singlePlacements: singleColPlacements[col],\n          fgContentElRef: _this7.fgElRefs.createRef(cell.key),\n          fgContent: // Fragment scopes the keys\n          createElement(Fragment, null, createElement(Fragment, null, normalFgNodes), createElement(Fragment, null, mirrorFgNodes)),\n          bgContent: // Fragment scopes the keys\n          createElement(Fragment, null, _this7.renderFillSegs(highlightSegsByCol[col], 'highlight'), _this7.renderFillSegs(businessHoursByCol[col], 'non-business'), _this7.renderFillSegs(bgEventSegsByCol[col], 'bg-event'))\n        });\n      }));\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.updateSizing(true);\n      this.context.addResizeHandler(this.handleResize);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      var currentProps = this.props;\n      this.updateSizing(!isPropsEqual(prevProps, currentProps));\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.context.removeResizeHandler(this.handleResize);\n    }\n  }, {\n    key: \"getHighlightSegs\",\n    value: function getHighlightSegs() {\n      var props = this.props;\n\n      if (props.eventDrag && props.eventDrag.segs.length) {\n        // messy check\n        return props.eventDrag.segs;\n      }\n\n      if (props.eventResize && props.eventResize.segs.length) {\n        // messy check\n        return props.eventResize.segs;\n      }\n\n      return props.dateSelectionSegs;\n    }\n  }, {\n    key: \"getMirrorSegs\",\n    value: function getMirrorSegs() {\n      var props = this.props;\n\n      if (props.eventResize && props.eventResize.segs.length) {\n        // messy check\n        return props.eventResize.segs;\n      }\n\n      return [];\n    }\n  }, {\n    key: \"renderFgSegs\",\n    value: function renderFgSegs(col, segPlacements, todayRange, isForcedInvisible, isDragging, isResizing, isDateSelecting) {\n      var context = this.context;\n      var eventSelection = this.props.eventSelection;\n      var framePositions = this.state.framePositions;\n      var defaultDisplayEventEnd = this.props.cells.length === 1; // colCnt === 1\n\n      var isMirror = isDragging || isResizing || isDateSelecting;\n      var nodes = [];\n\n      if (framePositions) {\n        var _iterator9 = _createForOfIteratorHelper(segPlacements),\n            _step9;\n\n        try {\n          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n            var placement = _step9.value;\n            var seg = placement.seg;\n            var instanceId = seg.eventRange.instance.instanceId;\n            var key = instanceId + ':' + col;\n            var isVisible = placement.isVisible && !isForcedInvisible[instanceId];\n            var isAbsolute = placement.isAbsolute;\n            var left = '';\n            var right = '';\n\n            if (isAbsolute) {\n              if (context.isRtl) {\n                right = 0;\n                left = framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol];\n              } else {\n                left = 0;\n                right = framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol];\n              }\n            }\n            /*\n            known bug: events that are force to be list-item but span multiple days still take up space in later columns\n            todo: in print view, for multi-day events, don't display title within non-start/end segs\n            */\n\n\n            nodes.push(createElement(\"div\", {\n              className: 'fc-daygrid-event-harness' + (isAbsolute ? ' fc-daygrid-event-harness-abs' : ''),\n              key: key,\n              ref: isMirror ? null : this.segHarnessRefs.createRef(key),\n              style: {\n                visibility: isVisible ? '' : 'hidden',\n                marginTop: isAbsolute ? '' : placement.marginTop,\n                top: isAbsolute ? placement.absoluteTop : '',\n                left: left,\n                right: right\n              }\n            }, hasListItemDisplay(seg) ? createElement(TableListItemEvent, Object.assign({\n              seg: seg,\n              isDragging: isDragging,\n              isSelected: instanceId === eventSelection,\n              defaultDisplayEventEnd: defaultDisplayEventEnd\n            }, getSegMeta(seg, todayRange))) : createElement(TableBlockEvent, Object.assign({\n              seg: seg,\n              isDragging: isDragging,\n              isResizing: isResizing,\n              isDateSelecting: isDateSelecting,\n              isSelected: instanceId === eventSelection,\n              defaultDisplayEventEnd: defaultDisplayEventEnd\n            }, getSegMeta(seg, todayRange)))));\n          }\n        } catch (err) {\n          _iterator9.e(err);\n        } finally {\n          _iterator9.f();\n        }\n      }\n\n      return nodes;\n    }\n  }, {\n    key: \"renderFillSegs\",\n    value: function renderFillSegs(segs, fillType) {\n      var isRtl = this.context.isRtl;\n      var todayRange = this.props.todayRange;\n      var framePositions = this.state.framePositions;\n      var nodes = [];\n\n      if (framePositions) {\n        var _iterator10 = _createForOfIteratorHelper(segs),\n            _step10;\n\n        try {\n          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n            var seg = _step10.value;\n            var leftRightCss = isRtl ? {\n              right: 0,\n              left: framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol]\n            } : {\n              left: 0,\n              right: framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol]\n            };\n            nodes.push(createElement(\"div\", {\n              key: buildEventRangeKey(seg.eventRange),\n              className: \"fc-daygrid-bg-harness\",\n              style: leftRightCss\n            }, fillType === 'bg-event' ? createElement(BgEvent, Object.assign({\n              seg: seg\n            }, getSegMeta(seg, todayRange))) : renderFill(fillType)));\n          }\n        } catch (err) {\n          _iterator10.e(err);\n        } finally {\n          _iterator10.f();\n        }\n      }\n\n      return createElement.apply(void 0, [Fragment, {}].concat(nodes));\n    }\n  }, {\n    key: \"updateSizing\",\n    value: function updateSizing(isExternalSizingChange) {\n      var props = this.props,\n          frameElRefs = this.frameElRefs;\n\n      if (!props.forPrint && props.clientWidth !== null // positioning ready?\n      ) {\n        if (isExternalSizingChange) {\n          var frameEls = props.cells.map(function (cell) {\n            return frameElRefs.currentMap[cell.key];\n          });\n\n          if (frameEls.length) {\n            var originEl = this.rootElRef.current;\n            this.setState({\n              framePositions: new PositionCache(originEl, frameEls, true, // isHorizontal\n              false)\n            });\n          }\n        }\n\n        var oldInstanceHeights = this.state.eventInstanceHeights;\n        var newInstanceHeights = this.queryEventInstanceHeights();\n        var limitByContentHeight = props.dayMaxEvents === true || props.dayMaxEventRows === true;\n        this.safeSetState({\n          // HACK to prevent oscillations of events being shown/hidden from max-event-rows\n          // Essentially, once you compute an element's height, never null-out.\n          // TODO: always display all events, as visibility:hidden?\n          eventInstanceHeights: Object.assign(Object.assign({}, oldInstanceHeights), newInstanceHeights),\n          maxContentHeight: limitByContentHeight ? this.computeMaxContentHeight() : null\n        });\n      }\n    }\n  }, {\n    key: \"queryEventInstanceHeights\",\n    value: function queryEventInstanceHeights() {\n      var segElMap = this.segHarnessRefs.currentMap;\n      var eventInstanceHeights = {}; // get the max height amongst instance segs\n\n      for (var key in segElMap) {\n        var height = Math.round(segElMap[key].getBoundingClientRect().height);\n        var instanceId = key.split(':')[0]; // deconstruct how renderFgSegs makes the key\n\n        eventInstanceHeights[instanceId] = Math.max(eventInstanceHeights[instanceId] || 0, height);\n      }\n\n      return eventInstanceHeights;\n    }\n  }, {\n    key: \"computeMaxContentHeight\",\n    value: function computeMaxContentHeight() {\n      var firstKey = this.props.cells[0].key;\n      var cellEl = this.cellElRefs.currentMap[firstKey];\n      var fcContainerEl = this.fgElRefs.currentMap[firstKey];\n      return cellEl.getBoundingClientRect().bottom - fcContainerEl.getBoundingClientRect().top;\n    }\n  }, {\n    key: \"getCellEls\",\n    value: function getCellEls() {\n      var elMap = this.cellElRefs.currentMap;\n      return this.props.cells.map(function (cell) {\n        return elMap[cell.key];\n      });\n    }\n  }]);\n\n  return TableRow;\n}(DateComponent);\n\nTableRow.addStateEquality({\n  eventInstanceHeights: isPropsEqual\n});\n\nfunction buildMirrorPlacements(mirrorSegs, colPlacements) {\n  if (!mirrorSegs.length) {\n    return [];\n  }\n\n  var topsByInstanceId = buildAbsoluteTopHash(colPlacements); // TODO: cache this at first render?\n\n  return mirrorSegs.map(function (seg) {\n    return {\n      seg: seg,\n      isVisible: true,\n      isAbsolute: true,\n      absoluteTop: topsByInstanceId[seg.eventRange.instance.instanceId],\n      marginTop: 0\n    };\n  });\n}\n\nfunction buildAbsoluteTopHash(colPlacements) {\n  var topsByInstanceId = {};\n\n  var _iterator11 = _createForOfIteratorHelper(colPlacements),\n      _step11;\n\n  try {\n    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n      var placements = _step11.value;\n\n      var _iterator12 = _createForOfIteratorHelper(placements),\n          _step12;\n\n      try {\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          var placement = _step12.value;\n          topsByInstanceId[placement.seg.eventRange.instance.instanceId] = placement.absoluteTop;\n        }\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n    }\n  } catch (err) {\n    _iterator11.e(err);\n  } finally {\n    _iterator11.f();\n  }\n\n  return topsByInstanceId;\n}\n\nvar Table = /*#__PURE__*/function (_DateComponent4) {\n  _inherits(Table, _DateComponent4);\n\n  var _super8 = _createSuper(Table);\n\n  function Table() {\n    var _this8;\n\n    _classCallCheck(this, Table);\n\n    _this8 = _super8.apply(this, arguments);\n    _this8.splitBusinessHourSegs = memoize(splitSegsByRow);\n    _this8.splitBgEventSegs = memoize(splitSegsByRow);\n    _this8.splitFgEventSegs = memoize(splitSegsByRow);\n    _this8.splitDateSelectionSegs = memoize(splitSegsByRow);\n    _this8.splitEventDrag = memoize(splitInteractionByRow);\n    _this8.splitEventResize = memoize(splitInteractionByRow);\n    _this8.rowRefs = new RefMap();\n\n    _this8.handleRootEl = function (rootEl) {\n      _this8.rootEl = rootEl;\n\n      if (rootEl) {\n        _this8.context.registerInteractiveComponent(_assertThisInitialized(_this8), {\n          el: rootEl,\n          isHitComboAllowed: _this8.props.isHitComboAllowed\n        });\n      } else {\n        _this8.context.unregisterInteractiveComponent(_assertThisInitialized(_this8));\n      }\n    };\n\n    return _this8;\n  }\n\n  _createClass(Table, [{\n    key: \"render\",\n    value: function render() {\n      var _this9 = this;\n\n      var props = this.props;\n      var dateProfile = props.dateProfile,\n          dayMaxEventRows = props.dayMaxEventRows,\n          dayMaxEvents = props.dayMaxEvents,\n          expandRows = props.expandRows;\n      var rowCnt = props.cells.length;\n      var businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, rowCnt);\n      var bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, rowCnt);\n      var fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, rowCnt);\n      var dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, rowCnt);\n      var eventDragByRow = this.splitEventDrag(props.eventDrag, rowCnt);\n      var eventResizeByRow = this.splitEventResize(props.eventResize, rowCnt);\n      var limitViaBalanced = dayMaxEvents === true || dayMaxEventRows === true; // if rows can't expand to fill fixed height, can't do balanced-height event limit\n      // TODO: best place to normalize these options?\n\n      if (limitViaBalanced && !expandRows) {\n        limitViaBalanced = false;\n        dayMaxEventRows = null;\n        dayMaxEvents = null;\n      }\n\n      var classNames = ['fc-daygrid-body', limitViaBalanced ? 'fc-daygrid-body-balanced' : 'fc-daygrid-body-unbalanced', expandRows ? '' : 'fc-daygrid-body-natural' // will height of one row depend on the others?\n      ];\n      return createElement(\"div\", {\n        className: classNames.join(' '),\n        ref: this.handleRootEl,\n        style: {\n          // these props are important to give this wrapper correct dimensions for interactions\n          // TODO: if we set it here, can we avoid giving to inner tables?\n          width: props.clientWidth,\n          minWidth: props.tableMinWidth\n        }\n      }, createElement(NowTimer, {\n        unit: \"day\"\n      }, function (nowDate, todayRange) {\n        return createElement(Fragment, null, createElement(\"table\", {\n          role: \"presentation\",\n          className: \"fc-scrollgrid-sync-table\",\n          style: {\n            width: props.clientWidth,\n            minWidth: props.tableMinWidth,\n            height: expandRows ? props.clientHeight : ''\n          }\n        }, props.colGroupNode, createElement(\"tbody\", {\n          role: \"presentation\"\n        }, props.cells.map(function (cells, row) {\n          return createElement(TableRow, {\n            ref: _this9.rowRefs.createRef(row),\n            key: cells.length ? cells[0].date.toISOString()\n            /* best? or put key on cell? or use diff formatter? */\n            : row // in case there are no cells (like when resource view is loading)\n            ,\n            showDayNumbers: rowCnt > 1,\n            showWeekNumbers: props.showWeekNumbers,\n            todayRange: todayRange,\n            dateProfile: dateProfile,\n            cells: cells,\n            renderIntro: props.renderRowIntro,\n            businessHourSegs: businessHourSegsByRow[row],\n            eventSelection: props.eventSelection,\n            bgEventSegs: bgEventSegsByRow[row].filter(isSegAllDay)\n            /* hack */\n            ,\n            fgEventSegs: fgEventSegsByRow[row],\n            dateSelectionSegs: dateSelectionSegsByRow[row],\n            eventDrag: eventDragByRow[row],\n            eventResize: eventResizeByRow[row],\n            dayMaxEvents: dayMaxEvents,\n            dayMaxEventRows: dayMaxEventRows,\n            clientWidth: props.clientWidth,\n            clientHeight: props.clientHeight,\n            forPrint: props.forPrint\n          });\n        }))));\n      }));\n    } // Hit System\n    // ----------------------------------------------------------------------------------------------------\n\n  }, {\n    key: \"prepareHits\",\n    value: function prepareHits() {\n      this.rowPositions = new PositionCache(this.rootEl, this.rowRefs.collect().map(function (rowObj) {\n        return rowObj.getCellEls()[0];\n      }), // first cell el in each row. TODO: not optimal\n      false, true);\n      this.colPositions = new PositionCache(this.rootEl, this.rowRefs.currentMap[0].getCellEls(), // cell els in first row\n      true, // horizontal\n      false);\n    }\n  }, {\n    key: \"queryHit\",\n    value: function queryHit(positionLeft, positionTop) {\n      var colPositions = this.colPositions,\n          rowPositions = this.rowPositions;\n      var col = colPositions.leftToIndex(positionLeft);\n      var row = rowPositions.topToIndex(positionTop);\n\n      if (row != null && col != null) {\n        var cell = this.props.cells[row][col];\n        return {\n          dateProfile: this.props.dateProfile,\n          dateSpan: Object.assign({\n            range: this.getCellRange(row, col),\n            allDay: true\n          }, cell.extraDateSpan),\n          dayEl: this.getCellEl(row, col),\n          rect: {\n            left: colPositions.lefts[col],\n            right: colPositions.rights[col],\n            top: rowPositions.tops[row],\n            bottom: rowPositions.bottoms[row]\n          },\n          layer: 0\n        };\n      }\n\n      return null;\n    }\n  }, {\n    key: \"getCellEl\",\n    value: function getCellEl(row, col) {\n      return this.rowRefs.currentMap[row].getCellEls()[col]; // TODO: not optimal\n    }\n  }, {\n    key: \"getCellRange\",\n    value: function getCellRange(row, col) {\n      var start = this.props.cells[row][col].date;\n      var end = addDays(start, 1);\n      return {\n        start: start,\n        end: end\n      };\n    }\n  }]);\n\n  return Table;\n}(DateComponent);\n\nfunction isSegAllDay(seg) {\n  return seg.eventRange.def.allDay;\n}\n\nvar DayTableSlicer = /*#__PURE__*/function (_Slicer) {\n  _inherits(DayTableSlicer, _Slicer);\n\n  var _super9 = _createSuper(DayTableSlicer);\n\n  function DayTableSlicer() {\n    var _this10;\n\n    _classCallCheck(this, DayTableSlicer);\n\n    _this10 = _super9.apply(this, arguments);\n    _this10.forceDayIfListItem = true;\n    return _this10;\n  }\n\n  _createClass(DayTableSlicer, [{\n    key: \"sliceRange\",\n    value: function sliceRange(dateRange, dayTableModel) {\n      return dayTableModel.sliceRange(dateRange);\n    }\n  }]);\n\n  return DayTableSlicer;\n}(Slicer);\n\nvar DayTable = /*#__PURE__*/function (_DateComponent5) {\n  _inherits(DayTable, _DateComponent5);\n\n  var _super10 = _createSuper(DayTable);\n\n  function DayTable() {\n    var _this11;\n\n    _classCallCheck(this, DayTable);\n\n    _this11 = _super10.apply(this, arguments);\n    _this11.slicer = new DayTableSlicer();\n    _this11.tableRef = createRef();\n    return _this11;\n  }\n\n  _createClass(DayTable, [{\n    key: \"render\",\n    value: function render() {\n      var props = this.props,\n          context = this.context;\n      return createElement(Table, Object.assign({\n        ref: this.tableRef\n      }, this.slicer.sliceProps(props, props.dateProfile, props.nextDayThreshold, context, props.dayTableModel), {\n        dateProfile: props.dateProfile,\n        cells: props.dayTableModel.cells,\n        colGroupNode: props.colGroupNode,\n        tableMinWidth: props.tableMinWidth,\n        renderRowIntro: props.renderRowIntro,\n        dayMaxEvents: props.dayMaxEvents,\n        dayMaxEventRows: props.dayMaxEventRows,\n        showWeekNumbers: props.showWeekNumbers,\n        expandRows: props.expandRows,\n        headerAlignElRef: props.headerAlignElRef,\n        clientWidth: props.clientWidth,\n        clientHeight: props.clientHeight,\n        forPrint: props.forPrint\n      }));\n    }\n  }]);\n\n  return DayTable;\n}(DateComponent);\n\nvar DayTableView = /*#__PURE__*/function (_TableView) {\n  _inherits(DayTableView, _TableView);\n\n  var _super11 = _createSuper(DayTableView);\n\n  function DayTableView() {\n    var _this12;\n\n    _classCallCheck(this, DayTableView);\n\n    _this12 = _super11.apply(this, arguments);\n    _this12.buildDayTableModel = memoize(buildDayTableModel);\n    _this12.headerRef = createRef();\n    _this12.tableRef = createRef();\n    return _this12;\n  }\n\n  _createClass(DayTableView, [{\n    key: \"render\",\n    value: function render() {\n      var _this13 = this;\n\n      var _this$context = this.context,\n          options = _this$context.options,\n          dateProfileGenerator = _this$context.dateProfileGenerator;\n      var props = this.props;\n      var dayTableModel = this.buildDayTableModel(props.dateProfile, dateProfileGenerator);\n      var headerContent = options.dayHeaders && createElement(DayHeader, {\n        ref: this.headerRef,\n        dateProfile: props.dateProfile,\n        dates: dayTableModel.headerDates,\n        datesRepDistinctDays: dayTableModel.rowCnt === 1\n      });\n\n      var bodyContent = function bodyContent(contentArg) {\n        return createElement(DayTable, {\n          ref: _this13.tableRef,\n          dateProfile: props.dateProfile,\n          dayTableModel: dayTableModel,\n          businessHours: props.businessHours,\n          dateSelection: props.dateSelection,\n          eventStore: props.eventStore,\n          eventUiBases: props.eventUiBases,\n          eventSelection: props.eventSelection,\n          eventDrag: props.eventDrag,\n          eventResize: props.eventResize,\n          nextDayThreshold: options.nextDayThreshold,\n          colGroupNode: contentArg.tableColGroupNode,\n          tableMinWidth: contentArg.tableMinWidth,\n          dayMaxEvents: options.dayMaxEvents,\n          dayMaxEventRows: options.dayMaxEventRows,\n          showWeekNumbers: options.weekNumbers,\n          expandRows: !props.isHeightAuto,\n          headerAlignElRef: _this13.headerElRef,\n          clientWidth: contentArg.clientWidth,\n          clientHeight: contentArg.clientHeight,\n          forPrint: props.forPrint\n        });\n      };\n\n      return options.dayMinWidth ? this.renderHScrollLayout(headerContent, bodyContent, dayTableModel.colCnt, options.dayMinWidth) : this.renderSimpleLayout(headerContent, bodyContent);\n    }\n  }]);\n\n  return DayTableView;\n}(TableView);\n\nfunction buildDayTableModel(dateProfile, dateProfileGenerator) {\n  var daySeries = new DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);\n  return new DayTableModel(daySeries, /year|month|week/.test(dateProfile.currentRangeUnit));\n}\n\nexport { DayTableView as DayGridView, DayTable, DayTableSlicer, Table, TableView, buildDayTableModel };","map":null,"metadata":{},"sourceType":"module"}