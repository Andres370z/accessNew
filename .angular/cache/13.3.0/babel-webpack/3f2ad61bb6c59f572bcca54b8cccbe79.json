{"ast":null,"code":"import _classCallCheck from \"/Users/apple/Documents/AccessControlSoft/accesscontrolsoft/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Documents/AccessControlSoft/accesscontrolsoft/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport * as i0 from '@angular/core';\nimport { EventEmitter, Component, Input, Output, ViewChild, NgModule } from '@angular/core';\nimport * as i1 from '@angular/common';\nimport { CommonModule } from '@angular/common';\n/**\r\n * Container class for a captured webcam image\r\n * @author basst314, davidshen84\r\n */\n\nvar _c0 = [\"video\"];\nvar _c1 = [\"canvas\"];\n\nfunction WebcamComponent_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    var _r4 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 6);\n    i0.ɵɵlistener(\"click\", function WebcamComponent_div_3_Template_div_click_0_listener() {\n      i0.ɵɵrestoreView(_r4);\n      var ctx_r3 = i0.ɵɵnextContext();\n      return ctx_r3.rotateVideoInput(true);\n    });\n    i0.ɵɵelementEnd();\n  }\n}\n\nvar WebcamImage = /*#__PURE__*/function () {\n  function WebcamImage(imageAsDataUrl, mimeType, imageData) {\n    _classCallCheck(this, WebcamImage);\n\n    this._mimeType = null;\n    this._imageAsBase64 = null;\n    this._imageAsDataUrl = null;\n    this._imageData = null;\n    this._mimeType = mimeType;\n    this._imageAsDataUrl = imageAsDataUrl;\n    this._imageData = imageData;\n  }\n  /**\r\n   * Extracts the Base64 data out of the given dataUrl.\r\n   * @param dataUrl the given dataUrl\r\n   * @param mimeType the mimeType of the data\r\n   */\n\n\n  _createClass(WebcamImage, [{\n    key: \"imageAsBase64\",\n    get:\n    /**\r\n     * Get the base64 encoded image data\r\n     * @returns base64 data of the image\r\n     */\n    function get() {\n      return this._imageAsBase64 ? this._imageAsBase64 : this._imageAsBase64 = WebcamImage.getDataFromDataUrl(this._imageAsDataUrl, this._mimeType);\n    }\n    /**\r\n     * Get the encoded image as dataUrl\r\n     * @returns the dataUrl of the image\r\n     */\n\n  }, {\n    key: \"imageAsDataUrl\",\n    get: function get() {\n      return this._imageAsDataUrl;\n    }\n    /**\r\n     * Get the ImageData object associated with the canvas' 2d context.\r\n     * @returns the ImageData of the canvas's 2d context.\r\n     */\n\n  }, {\n    key: \"imageData\",\n    get: function get() {\n      return this._imageData;\n    }\n  }], [{\n    key: \"getDataFromDataUrl\",\n    value: function getDataFromDataUrl(dataUrl, mimeType) {\n      return dataUrl.replace(\"data:\".concat(mimeType, \";base64,\"), '');\n    }\n  }]);\n\n  return WebcamImage;\n}();\n\nvar WebcamUtil = /*#__PURE__*/function () {\n  function WebcamUtil() {\n    _classCallCheck(this, WebcamUtil);\n  }\n\n  _createClass(WebcamUtil, null, [{\n    key: \"getAvailableVideoInputs\",\n    value:\n    /**\r\n     * Lists available videoInput devices\r\n     * @returns a list of media device info.\r\n     */\n    function getAvailableVideoInputs() {\n      if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {\n        return Promise.reject('enumerateDevices() not supported.');\n      }\n\n      return new Promise(function (resolve, reject) {\n        navigator.mediaDevices.enumerateDevices().then(function (devices) {\n          resolve(devices.filter(function (device) {\n            return device.kind === 'videoinput';\n          }));\n        }).catch(function (err) {\n          reject(err.message || err);\n        });\n      });\n    }\n  }]);\n\n  return WebcamUtil;\n}();\n\nvar WebcamComponent = /*#__PURE__*/(function () {\n  var WebcamComponent = /*#__PURE__*/function () {\n    function WebcamComponent() {\n      _classCallCheck(this, WebcamComponent);\n\n      /** Defines the max width of the webcam area in px */\n      this.width = 640;\n      /** Defines the max height of the webcam area in px */\n\n      this.height = 480;\n      /** Defines base constraints to apply when requesting video track from UserMedia */\n\n      this.videoOptions = WebcamComponent.DEFAULT_VIDEO_OPTIONS;\n      /** Flag to enable/disable camera switch. If enabled, a switch icon will be displayed if multiple cameras were found */\n\n      this.allowCameraSwitch = true;\n      /** Flag to control whether an ImageData object is stored into the WebcamImage object. */\n\n      this.captureImageData = false;\n      /** The image type to use when capturing snapshots */\n\n      this.imageType = WebcamComponent.DEFAULT_IMAGE_TYPE;\n      /** The image quality to use when capturing snapshots (number between 0 and 1) */\n\n      this.imageQuality = WebcamComponent.DEFAULT_IMAGE_QUALITY;\n      /** EventEmitter which fires when an image has been captured */\n\n      this.imageCapture = new EventEmitter();\n      /** Emits a mediaError if webcam cannot be initialized (e.g. missing user permissions) */\n\n      this.initError = new EventEmitter();\n      /** Emits when the webcam video was clicked */\n\n      this.imageClick = new EventEmitter();\n      /** Emits the active deviceId after the active video device was switched */\n\n      this.cameraSwitched = new EventEmitter();\n      /** available video devices */\n\n      this.availableVideoInputs = [];\n      /** Indicates whether the video device is ready to be switched */\n\n      this.videoInitialized = false;\n      /** Index of active video in availableVideoInputs */\n\n      this.activeVideoInputIndex = -1;\n      /** MediaStream object in use for streaming UserMedia data */\n\n      this.mediaStream = null;\n      /** width and height of the active video stream */\n\n      this.activeVideoSettings = null;\n    }\n    /**\r\n     * If the given Observable emits, an image will be captured and emitted through 'imageCapture' EventEmitter\r\n     */\n\n\n    _createClass(WebcamComponent, [{\n      key: \"trigger\",\n      set: function set(trigger) {\n        var _this = this;\n\n        if (this.triggerSubscription) {\n          this.triggerSubscription.unsubscribe();\n        } // Subscribe to events from this Observable to take snapshots\n\n\n        this.triggerSubscription = trigger.subscribe(function () {\n          _this.takeSnapshot();\n        });\n      }\n      /**\r\n       * If the given Observable emits, the active webcam will be switched to the one indicated by the emitted value.\r\n       * @param switchCamera Indicates which webcam to switch to\r\n       *   true: cycle forwards through available webcams\r\n       *   false: cycle backwards through available webcams\r\n       *   string: activate the webcam with the given id\r\n       */\n\n    }, {\n      key: \"switchCamera\",\n      set: function set(switchCamera) {\n        var _this2 = this;\n\n        if (this.switchCameraSubscription) {\n          this.switchCameraSubscription.unsubscribe();\n        } // Subscribe to events from this Observable to switch video device\n\n\n        this.switchCameraSubscription = switchCamera.subscribe(function (value) {\n          if (typeof value === 'string') {\n            // deviceId was specified\n            _this2.switchToVideoInput(value);\n          } else {\n            // direction was specified\n            _this2.rotateVideoInput(value !== false);\n          }\n        });\n      }\n      /**\r\n       * Get MediaTrackConstraints to request streaming the given device\r\n       * @param deviceId\r\n       * @param baseMediaTrackConstraints base constraints to merge deviceId-constraint into\r\n       * @returns\r\n       */\n\n    }, {\n      key: \"ngAfterViewInit\",\n      value: function ngAfterViewInit() {\n        var _this3 = this;\n\n        this.detectAvailableDevices().then(function () {\n          // start video\n          _this3.switchToVideoInput(null);\n        }).catch(function (err) {\n          _this3.initError.next({\n            message: err\n          }); // fallback: still try to load webcam, even if device enumeration failed\n\n\n          _this3.switchToVideoInput(null);\n        });\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.stopMediaTracks();\n        this.unsubscribeFromSubscriptions();\n      }\n      /**\r\n       * Takes a snapshot of the current webcam's view and emits the image as an event\r\n       */\n\n    }, {\n      key: \"takeSnapshot\",\n      value: function takeSnapshot() {\n        // set canvas size to actual video size\n        var _video = this.nativeVideoElement;\n        var dimensions = {\n          width: this.width,\n          height: this.height\n        };\n\n        if (_video.videoWidth) {\n          dimensions.width = _video.videoWidth;\n          dimensions.height = _video.videoHeight;\n        }\n\n        var _canvas = this.canvas.nativeElement;\n        _canvas.width = dimensions.width;\n        _canvas.height = dimensions.height; // paint snapshot image to canvas\n\n        var context2d = _canvas.getContext('2d');\n\n        context2d.drawImage(_video, 0, 0); // read canvas content as image\n\n        var mimeType = this.imageType ? this.imageType : WebcamComponent.DEFAULT_IMAGE_TYPE;\n        var quality = this.imageQuality ? this.imageQuality : WebcamComponent.DEFAULT_IMAGE_QUALITY;\n\n        var dataUrl = _canvas.toDataURL(mimeType, quality); // get the ImageData object from the canvas' context.\n\n\n        var imageData = null;\n\n        if (this.captureImageData) {\n          imageData = context2d.getImageData(0, 0, _canvas.width, _canvas.height);\n        }\n\n        this.imageCapture.next(new WebcamImage(dataUrl, mimeType, imageData));\n      }\n      /**\r\n       * Switches to the next/previous video device\r\n       * @param forward\r\n       */\n\n    }, {\n      key: \"rotateVideoInput\",\n      value: function rotateVideoInput(forward) {\n        if (this.availableVideoInputs && this.availableVideoInputs.length > 1) {\n          var increment = forward ? 1 : this.availableVideoInputs.length - 1;\n          var nextInputIndex = (this.activeVideoInputIndex + increment) % this.availableVideoInputs.length;\n          this.switchToVideoInput(this.availableVideoInputs[nextInputIndex].deviceId);\n        }\n      }\n      /**\r\n       * Switches the camera-view to the specified video device\r\n       */\n\n    }, {\n      key: \"switchToVideoInput\",\n      value: function switchToVideoInput(deviceId) {\n        this.videoInitialized = false;\n        this.stopMediaTracks();\n        this.initWebcam(deviceId, this.videoOptions);\n      }\n      /**\r\n       * Event-handler for video resize event.\r\n       * Triggers Angular change detection so that new video dimensions get applied\r\n       */\n\n    }, {\n      key: \"videoResize\",\n      value: function videoResize() {// here to trigger Angular change detection\n      }\n    }, {\n      key: \"videoWidth\",\n      get: function get() {\n        var videoRatio = this.getVideoAspectRatio();\n        return Math.min(this.width, this.height * videoRatio);\n      }\n    }, {\n      key: \"videoHeight\",\n      get: function get() {\n        var videoRatio = this.getVideoAspectRatio();\n        return Math.min(this.height, this.width / videoRatio);\n      }\n    }, {\n      key: \"videoStyleClasses\",\n      get: function get() {\n        var classes = '';\n\n        if (this.isMirrorImage()) {\n          classes += 'mirrored ';\n        }\n\n        return classes.trim();\n      }\n    }, {\n      key: \"nativeVideoElement\",\n      get: function get() {\n        return this.video.nativeElement;\n      }\n      /**\r\n       * Returns the video aspect ratio of the active video stream\r\n       */\n\n    }, {\n      key: \"getVideoAspectRatio\",\n      value: function getVideoAspectRatio() {\n        // calculate ratio from video element dimensions if present\n        var videoElement = this.nativeVideoElement;\n\n        if (videoElement.videoWidth && videoElement.videoWidth > 0 && videoElement.videoHeight && videoElement.videoHeight > 0) {\n          return videoElement.videoWidth / videoElement.videoHeight;\n        } // nothing present - calculate ratio based on width/height params\n\n\n        return this.width / this.height;\n      }\n      /**\r\n       * Init webcam live view\r\n       */\n\n    }, {\n      key: \"initWebcam\",\n      value: function initWebcam(deviceId, userVideoTrackConstraints) {\n        var _this4 = this;\n\n        var _video = this.nativeVideoElement;\n\n        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n          // merge deviceId -> userVideoTrackConstraints\n          var videoTrackConstraints = WebcamComponent.getMediaConstraintsForDevice(deviceId, userVideoTrackConstraints);\n          navigator.mediaDevices.getUserMedia({\n            video: videoTrackConstraints\n          }).then(function (stream) {\n            _this4.mediaStream = stream;\n            _video.srcObject = stream;\n\n            _video.play();\n\n            _this4.activeVideoSettings = stream.getVideoTracks()[0].getSettings();\n            var activeDeviceId = WebcamComponent.getDeviceIdFromMediaStreamTrack(stream.getVideoTracks()[0]);\n\n            _this4.cameraSwitched.next(activeDeviceId); // Initial detect may run before user gave permissions, returning no deviceIds. This prevents later camera switches. (#47)\n            // Run detect once again within getUserMedia callback, to make sure this time we have permissions and get deviceIds.\n\n\n            _this4.detectAvailableDevices().then(function () {\n              _this4.activeVideoInputIndex = activeDeviceId ? _this4.availableVideoInputs.findIndex(function (mediaDeviceInfo) {\n                return mediaDeviceInfo.deviceId === activeDeviceId;\n              }) : -1;\n              _this4.videoInitialized = true;\n            }).catch(function () {\n              _this4.activeVideoInputIndex = -1;\n              _this4.videoInitialized = true;\n            });\n          }).catch(function (err) {\n            _this4.initError.next({\n              message: err.message,\n              mediaStreamError: err\n            });\n          });\n        } else {\n          this.initError.next({\n            message: 'Cannot read UserMedia from MediaDevices.'\n          });\n        }\n      }\n    }, {\n      key: \"getActiveVideoTrack\",\n      value: function getActiveVideoTrack() {\n        return this.mediaStream ? this.mediaStream.getVideoTracks()[0] : null;\n      }\n    }, {\n      key: \"isMirrorImage\",\n      value: function isMirrorImage() {\n        if (!this.getActiveVideoTrack()) {\n          return false;\n        } // check for explicit mirror override parameter\n\n\n        {\n          var mirror = 'auto';\n\n          if (this.mirrorImage) {\n            if (typeof this.mirrorImage === 'string') {\n              mirror = String(this.mirrorImage).toLowerCase();\n            } else {\n              // WebcamMirrorProperties\n              if (this.mirrorImage.x) {\n                mirror = this.mirrorImage.x.toLowerCase();\n              }\n            }\n          }\n\n          switch (mirror) {\n            case 'always':\n              return true;\n\n            case 'never':\n              return false;\n          }\n        } // default: enable mirroring if webcam is user facing\n\n        return WebcamComponent.isUserFacing(this.getActiveVideoTrack());\n      }\n      /**\r\n       * Stops all active media tracks.\r\n       * This prevents the webcam from being indicated as active,\r\n       * even if it is no longer used by this component.\r\n       */\n\n    }, {\n      key: \"stopMediaTracks\",\n      value: function stopMediaTracks() {\n        if (this.mediaStream && this.mediaStream.getTracks) {\n          // pause video to prevent mobile browser freezes\n          this.nativeVideoElement.pause(); // getTracks() returns all media tracks (video+audio)\n\n          this.mediaStream.getTracks().forEach(function (track) {\n            return track.stop();\n          });\n        }\n      }\n      /**\r\n       * Unsubscribe from all open subscriptions\r\n       */\n\n    }, {\n      key: \"unsubscribeFromSubscriptions\",\n      value: function unsubscribeFromSubscriptions() {\n        if (this.triggerSubscription) {\n          this.triggerSubscription.unsubscribe();\n        }\n\n        if (this.switchCameraSubscription) {\n          this.switchCameraSubscription.unsubscribe();\n        }\n      }\n      /**\r\n       * Reads available input devices\r\n       */\n\n    }, {\n      key: \"detectAvailableDevices\",\n      value: function detectAvailableDevices() {\n        var _this5 = this;\n\n        return new Promise(function (resolve, reject) {\n          WebcamUtil.getAvailableVideoInputs().then(function (devices) {\n            _this5.availableVideoInputs = devices;\n            resolve(devices);\n          }).catch(function (err) {\n            _this5.availableVideoInputs = [];\n            reject(err);\n          });\n        });\n      }\n    }], [{\n      key: \"getMediaConstraintsForDevice\",\n      value: function getMediaConstraintsForDevice(deviceId, baseMediaTrackConstraints) {\n        var result = baseMediaTrackConstraints ? baseMediaTrackConstraints : this.DEFAULT_VIDEO_OPTIONS;\n\n        if (deviceId) {\n          result.deviceId = {\n            exact: deviceId\n          };\n        }\n\n        return result;\n      }\n      /**\r\n       * Tries to harvest the deviceId from the given mediaStreamTrack object.\r\n       * Browsers populate this object differently; this method tries some different approaches\r\n       * to read the id.\r\n       * @param mediaStreamTrack\r\n       * @returns deviceId if found in the mediaStreamTrack\r\n       */\n\n    }, {\n      key: \"getDeviceIdFromMediaStreamTrack\",\n      value: function getDeviceIdFromMediaStreamTrack(mediaStreamTrack) {\n        if (mediaStreamTrack.getSettings && mediaStreamTrack.getSettings() && mediaStreamTrack.getSettings().deviceId) {\n          return mediaStreamTrack.getSettings().deviceId;\n        } else if (mediaStreamTrack.getConstraints && mediaStreamTrack.getConstraints() && mediaStreamTrack.getConstraints().deviceId) {\n          var deviceIdObj = mediaStreamTrack.getConstraints().deviceId;\n          return WebcamComponent.getValueFromConstrainDOMString(deviceIdObj);\n        }\n      }\n      /**\r\n       * Tries to harvest the facingMode from the given mediaStreamTrack object.\r\n       * Browsers populate this object differently; this method tries some different approaches\r\n       * to read the value.\r\n       * @param mediaStreamTrack\r\n       * @returns facingMode if found in the mediaStreamTrack\r\n       */\n\n    }, {\n      key: \"getFacingModeFromMediaStreamTrack\",\n      value: function getFacingModeFromMediaStreamTrack(mediaStreamTrack) {\n        if (mediaStreamTrack) {\n          if (mediaStreamTrack.getSettings && mediaStreamTrack.getSettings() && mediaStreamTrack.getSettings().facingMode) {\n            return mediaStreamTrack.getSettings().facingMode;\n          } else if (mediaStreamTrack.getConstraints && mediaStreamTrack.getConstraints() && mediaStreamTrack.getConstraints().facingMode) {\n            var facingModeConstraint = mediaStreamTrack.getConstraints().facingMode;\n            return WebcamComponent.getValueFromConstrainDOMString(facingModeConstraint);\n          }\n        }\n      }\n      /**\r\n       * Determines whether the given mediaStreamTrack claims itself as user facing\r\n       * @param mediaStreamTrack\r\n       */\n\n    }, {\n      key: \"isUserFacing\",\n      value: function isUserFacing(mediaStreamTrack) {\n        var facingMode = WebcamComponent.getFacingModeFromMediaStreamTrack(mediaStreamTrack);\n        return facingMode ? 'user' === facingMode.toLowerCase() : false;\n      }\n      /**\r\n       * Extracts the value from the given ConstrainDOMString\r\n       * @param constrainDOMString\r\n       */\n\n    }, {\n      key: \"getValueFromConstrainDOMString\",\n      value: function getValueFromConstrainDOMString(constrainDOMString) {\n        if (constrainDOMString) {\n          if (constrainDOMString instanceof String) {\n            return String(constrainDOMString);\n          } else if (Array.isArray(constrainDOMString) && Array(constrainDOMString).length > 0) {\n            return String(constrainDOMString[0]);\n          } else if (typeof constrainDOMString === 'object') {\n            if (constrainDOMString['exact']) {\n              return String(constrainDOMString['exact']);\n            } else if (constrainDOMString['ideal']) {\n              return String(constrainDOMString['ideal']);\n            }\n          }\n        }\n\n        return null;\n      }\n    }]);\n\n    return WebcamComponent;\n  }();\n\n  WebcamComponent.DEFAULT_VIDEO_OPTIONS = {\n    facingMode: 'environment'\n  };\n  WebcamComponent.DEFAULT_IMAGE_TYPE = 'image/jpeg';\n  WebcamComponent.DEFAULT_IMAGE_QUALITY = 0.92;\n\n  WebcamComponent.ɵfac = function WebcamComponent_Factory(t) {\n    return new (t || WebcamComponent)();\n  };\n\n  WebcamComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: WebcamComponent,\n    selectors: [[\"webcam\"]],\n    viewQuery: function WebcamComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 7);\n        i0.ɵɵviewQuery(_c1, 7);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.video = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.canvas = _t.first);\n      }\n    },\n    inputs: {\n      width: \"width\",\n      height: \"height\",\n      videoOptions: \"videoOptions\",\n      allowCameraSwitch: \"allowCameraSwitch\",\n      mirrorImage: \"mirrorImage\",\n      captureImageData: \"captureImageData\",\n      imageType: \"imageType\",\n      imageQuality: \"imageQuality\",\n      trigger: \"trigger\",\n      switchCamera: \"switchCamera\"\n    },\n    outputs: {\n      imageCapture: \"imageCapture\",\n      initError: \"initError\",\n      imageClick: \"imageClick\",\n      cameraSwitched: \"cameraSwitched\"\n    },\n    decls: 6,\n    vars: 7,\n    consts: [[1, \"webcam-wrapper\", 3, \"click\"], [\"autoplay\", \"\", \"muted\", \"\", \"playsinline\", \"\", 3, \"width\", \"height\", \"resize\"], [\"video\", \"\"], [\"class\", \"camera-switch\", 3, \"click\", 4, \"ngIf\"], [3, \"width\", \"height\"], [\"canvas\", \"\"], [1, \"camera-switch\", 3, \"click\"]],\n    template: function WebcamComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵlistener(\"click\", function WebcamComponent_Template_div_click_0_listener() {\n          return ctx.imageClick.next();\n        });\n        i0.ɵɵelementStart(1, \"video\", 1, 2);\n        i0.ɵɵlistener(\"resize\", function WebcamComponent_Template_video_resize_1_listener() {\n          return ctx.videoResize();\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(3, WebcamComponent_div_3_Template, 1, 0, \"div\", 3);\n        i0.ɵɵelement(4, \"canvas\", 4, 5);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵclassMap(ctx.videoStyleClasses);\n        i0.ɵɵproperty(\"width\", ctx.videoWidth)(\"height\", ctx.videoHeight);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.allowCameraSwitch && ctx.availableVideoInputs.length > 1 && ctx.videoInitialized);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"width\", ctx.width)(\"height\", ctx.height);\n      }\n    },\n    directives: [i1.NgIf],\n    styles: [\".webcam-wrapper[_ngcontent-%COMP%]{display:inline-block;position:relative;line-height:0}.webcam-wrapper[_ngcontent-%COMP%]   video.mirrored[_ngcontent-%COMP%]{transform:scaleX(-1)}.webcam-wrapper[_ngcontent-%COMP%]   canvas[_ngcontent-%COMP%]{display:none}.webcam-wrapper[_ngcontent-%COMP%]   .camera-switch[_ngcontent-%COMP%]{background-color:#0000001a;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAE9UlEQVR42u2aT2hdRRTGf+cRQqghSqihdBFDkRISK2KDfzDWxHaRQHEhaINKqa1gKQhd6EZLN+IidCH+Q0oWIkVRC21BQxXRitVaSbKoJSGtYGoK2tQ/tU1jY5v0c5F54Xl7b/KSO/PyEt+3e5f75p7zzZwzZ74zUEIJJfyfYaEGllQGVAGZlENdBy6Z2cSiYFTSKkkfS/pH/nBF0kFJdUW9AiRVASeAukD8DgNrzOySrwEzng18KaDzALXuG8W3AiStAvqBisBRNg40mtlPxbYCOgvgPO4bncWW+JpVeDQXRQhIygDfA00F5r0XuNfMrgclQFI98DDQCNQA5ZFXqoCWBVp8XwHRHeEqcN7loy/NbHBesyqpQ1KfFj/6nC+ZvFaApFrgPaCZpYVvgCfNbDiRAElNwGFg+RIt/X8H2s2s9wYCJDUAR4HqJX7++RN40MwGpgmQVAH0AQ2BPz4AHHPl8nBOAqtyFWQjsA6oL4Ada81sPDv7uwImod8kvSJp9RyS8O2SXnb/DYVd2Y9VSroQ4ANXJO2WVJmixqh0kzMWwL4LkiqRtDnA4D1zmfE8j9g9AezcnAHaPcfXdbfdnPZ2Yps6+DwAvO/Z1naTdApY7Xng48BDZnY1MpMVQBuw3iXc5Tnb0wBwBPjUzP6eoezuArZ6svM0geJLkvZEYnl3nkntoqROSbckSW2Suj3ZOIangc7GPJuUtNGdFIfmMeavktoSSKiW9LMPw30Q8JqkekmjCbOZRhuclLQjgYSNxUBAj6RyZ9ATgUJpUtJTCSR8vpAEXHAyWK5BXYFIGHOlepSAloUk4NEYgyoknQhEwhFJ0e8h6VSaQeerCb5uZgdi9utxYBNwOUD93hIVXswM4INCi6K9wAszFC2DwLOBDjHbYp59karIUnRdzYy/3ClqVklaUhfwTICj7K25OqA7a4wWagVsm4Me/xzwg2cCqqONFzO7DPxSCAJi436GUBgHHguQD2oTlJ55oSzP9ybccsttSJw1szdjFOSnI/8dTCGZHwcORp4Nx7y3B1iZ8/sm4MW8/Euxg5wIsS/HaAp3zeP4/G7obRDXI4jiTIA22H7Xdc7X+S3A5lC7QBQ357aq3VAjCeSkwUfAJrfvz+R8A9ADLAtZB+TinpjC5JMA+//jwPZZnF8G7J+L8z4IWB/zbG+gIujVWfLBW/NStVMmqaG4POJRsIjix7h8IGnLQuoBbQki5sVAJHyYm7YkNaRRtXwQ8G1cHpX0iKRrgUjYno17Sf0LrQhJUkdCeHWkVITGJI0k1QeS3ikGSUzOyJUJJNznYneuOCnpTldcxa2kP3xJYqOeSDjqZG8ShJLnE8TTuMS6Iyu1BW7djZqkfo9N0QOuYJmYQddfB7RG+gLTNzqAY9FrL+5/nwEbvDdJJe3zzOrhNP3AWRqmk55t3ZcBuj3b2gb0Sbrbo/NNzk7fFzu7s/E5EiC+rrmeQU0Kx2skvRFoOx2ZzlmSdgbsw49JetvtBpk8nM64d/cGbNtJ0s7cGyJlwHeEv+t3nqnLSgPAUOSGyG3AHUxdzqoJbEcvcL+ZTeTeEapzJKxgaeOcc/7Mf06D7kFrguS0VDAMtGadv+E47DT9tcChJej8ISfpD+abgTe45uOkFi8mnQ+JBVQ+d4VXuOptjavcyot8pq86mfwk8LWZnaOEEkoooYQSSojDv8AhQNeGfe0jAAAAAElFTkSuQmCC);background-repeat:no-repeat;border-radius:5px;position:absolute;right:13px;top:10px;height:48px;width:48px;background-size:80%;cursor:pointer;background-position:center;transition:background-color .2s ease}.webcam-wrapper[_ngcontent-%COMP%]   .camera-switch[_ngcontent-%COMP%]:hover{background-color:#0000002e}\"]\n  });\n  return WebcamComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar COMPONENTS = [WebcamComponent];\nvar WebcamModule = /*#__PURE__*/(function () {\n  var WebcamModule = /*#__PURE__*/_createClass(function WebcamModule() {\n    _classCallCheck(this, WebcamModule);\n  });\n\n  WebcamModule.ɵfac = function WebcamModule_Factory(t) {\n    return new (t || WebcamModule)();\n  };\n\n  WebcamModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: WebcamModule\n  });\n  WebcamModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return WebcamModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar WebcamInitError = /*#__PURE__*/_createClass(function WebcamInitError() {\n  _classCallCheck(this, WebcamInitError);\n\n  this.message = null;\n  this.mediaStreamError = null;\n});\n\nvar WebcamMirrorProperties = /*#__PURE__*/_createClass(function WebcamMirrorProperties() {\n  _classCallCheck(this, WebcamMirrorProperties);\n});\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { WebcamComponent, WebcamImage, WebcamInitError, WebcamMirrorProperties, WebcamModule, WebcamUtil };","map":null,"metadata":{},"sourceType":"module"}